---
title: Custom Tools
description: Give Claude the ability to call functions in your application
---

# Custom Tools

Custom tools let Claude call functions that execute in your application. When Claude decides to use a tool, the call is sent back to your app where the handler runs, and the result is returned to Claude.

## How It Works

```
Your App                    Chucky Cloud                    Claude
   │                             │                            │
   │  createSession(mcpServers)  │                            │
   │────────────────────────────►│                            │
   │                             │                            │
   │  send("Calculate 5 * 7")    │     prompt + tools         │
   │────────────────────────────►│───────────────────────────►│
   │                             │                            │
   │                             │     tool_call: calculate   │
   │   tool_call: calculate      │◄───────────────────────────│
   │◄────────────────────────────│                            │
   │                             │                            │
   │   [handler executes: 35]    │                            │
   │                             │                            │
   │   tool_result: 35           │     tool_result: 35        │
   │────────────────────────────►│───────────────────────────►│
   │                             │                            │
   │                             │     "The answer is 35"     │
   │   assistant message         │◄───────────────────────────│
   │◄────────────────────────────│                            │
```

## Quick Start

```typescript
import { createToken, createBudget, ChuckyClient, getAssistantText } from '@chucky.cloud/sdk';

// 1. Create a tool with a handler
const calculatorTool = {
  name: 'calculate',
  description: 'Perform a math calculation',
  inputSchema: {
    type: 'object',
    properties: {
      expression: { type: 'string', description: 'Math expression like "5 * 7"' },
    },
    required: ['expression'],
  },
  handler: async ({ expression }) => {
    // This runs in YOUR app, not on the server
    const result = eval(expression); // Use a proper math lib in production
    return { content: [{ type: 'text', text: String(result) }] };
  }
};

// 2. Create a session with the tool
const client = new ChuckyClient({ token });
const session = client.createSession({
  model: 'claude-sonnet-4-5-20250929',
  mcpServers: [{
    name: 'calculator',
    version: '1.0.0',
    tools: [calculatorTool]
  }],
});

// 3. Use it
await session.send('What is 15 * 7?');

for await (const msg of session.stream()) {
  if (msg.type === 'assistant') {
    console.log(getAssistantText(msg)); // "The result is 105"
  }
}

session.close();
```

## Tool Definition

A tool has four parts:

| Property | Type | Description |
|----------|------|-------------|
| `name` | `string` | Unique identifier for the tool |
| `description` | `string` | What the tool does (helps Claude decide when to use it) |
| `inputSchema` | `object` | JSON Schema defining the parameters |
| `handler` | `function` | Async function that executes when Claude calls the tool |

### Input Schema

Use JSON Schema to define parameters:

```typescript
const weatherTool = {
  name: 'get_weather',
  description: 'Get current weather for a location',
  inputSchema: {
    type: 'object',
    properties: {
      city: {
        type: 'string',
        description: 'City name'
      },
      unit: {
        type: 'string',
        enum: ['celsius', 'fahrenheit'],
        description: 'Temperature unit'
      },
    },
    required: ['city'],  // city is required, unit is optional
  },
  handler: async ({ city, unit = 'celsius' }) => {
    const weather = await fetchWeatherAPI(city, unit);
    return { content: [{ type: 'text', text: `${city}: ${weather.temp}°` }] };
  }
};
```

### Handler Function

The handler receives the parameters Claude provides and must return a `ToolResult`:

```typescript
// Success result
return {
  content: [{ type: 'text', text: 'Result here' }]
};

// Error result
return {
  content: [{ type: 'text', text: 'Error: Something went wrong' }],
  isError: true
};

// Image result
return {
  content: [{
    type: 'image',
    data: base64ImageData,
    mimeType: 'image/png'
  }]
};
```

## MCP Servers

Tools must be wrapped in an MCP server to use them:

```typescript
const mcpServer = {
  name: 'my-tools',      // Server name
  version: '1.0.0',       // Version string
  tools: [tool1, tool2]   // Array of tools
};

const session = client.createSession({
  mcpServers: [mcpServer],
});
```

You can have multiple MCP servers with different tools:

```typescript
const session = client.createSession({
  mcpServers: [
    { name: 'math', version: '1.0.0', tools: [addTool, multiplyTool] },
    { name: 'weather', version: '1.0.0', tools: [weatherTool] },
    { name: 'files', version: '1.0.0', tools: [readFileTool, writeFileTool] },
  ],
});
```

## Complete Example

```typescript
import { createToken, createBudget, ChuckyClient, getAssistantText } from '@chucky.cloud/sdk';

// Define tools
const getCurrentTime = {
  name: 'get_current_time',
  description: 'Get the current date and time',
  inputSchema: { type: 'object', properties: {} },
  handler: async () => {
    return { content: [{ type: 'text', text: new Date().toISOString() }] };
  }
};

const searchDatabase = {
  name: 'search_database',
  description: 'Search for users in the database',
  inputSchema: {
    type: 'object',
    properties: {
      query: { type: 'string', description: 'Search query' },
      limit: { type: 'number', description: 'Max results (default 10)' },
    },
    required: ['query'],
  },
  handler: async ({ query, limit = 10 }) => {
    // This runs in your app - you have access to your database
    const results = await db.users.search(query, { limit });
    return {
      content: [{
        type: 'text',
        text: JSON.stringify(results, null, 2)
      }]
    };
  }
};

const sendEmail = {
  name: 'send_email',
  description: 'Send an email to a user',
  inputSchema: {
    type: 'object',
    properties: {
      to: { type: 'string', description: 'Recipient email' },
      subject: { type: 'string', description: 'Email subject' },
      body: { type: 'string', description: 'Email body' },
    },
    required: ['to', 'subject', 'body'],
  },
  handler: async ({ to, subject, body }) => {
    await emailService.send({ to, subject, body });
    return { content: [{ type: 'text', text: `Email sent to ${to}` }] };
  }
};

// Create client and session
const token = await createToken({
  userId: 'user-123',
  projectId: process.env.PROJECT_ID,
  secret: process.env.HMAC_SECRET,
  budget: createBudget({ aiDollars: 1, computeHours: 1, window: 'day' }),
});

const client = new ChuckyClient({ token });
const session = client.createSession({
  model: 'claude-sonnet-4-5-20250929',
  systemPrompt: 'You are a helpful assistant with access to tools.',
  mcpServers: [{
    name: 'app-tools',
    version: '1.0.0',
    tools: [getCurrentTime, searchDatabase, sendEmail]
  }],
});

// Use the tools
await session.send('Find users named "John" and send them a welcome email');

for await (const msg of session.stream()) {
  if (msg.type === 'assistant') {
    console.log(getAssistantText(msg));
  }
  if (msg.type === 'result') {
    console.log('Done. Cost:', msg.total_cost_usd);
  }
}

session.close();
```

## Browser Example

Tools work the same in the browser - the handler runs in your web app:

```typescript
const showAlert = {
  name: 'show_alert',
  description: 'Show an alert dialog to the user',
  inputSchema: {
    type: 'object',
    properties: {
      message: { type: 'string', description: 'Alert message' },
    },
    required: ['message'],
  },
  handler: async ({ message }) => {
    alert(message);  // Runs in the browser!
    return { content: [{ type: 'text', text: 'Alert shown' }] };
  }
};

const highlightElement = {
  name: 'highlight_element',
  description: 'Highlight a DOM element',
  inputSchema: {
    type: 'object',
    properties: {
      selector: { type: 'string', description: 'CSS selector' },
      color: { type: 'string', description: 'Highlight color' },
    },
    required: ['selector'],
  },
  handler: async ({ selector, color = 'yellow' }) => {
    const el = document.querySelector(selector);
    if (!el) {
      return { content: [{ type: 'text', text: 'Element not found' }], isError: true };
    }
    el.style.backgroundColor = color;
    return { content: [{ type: 'text', text: `Highlighted ${selector}` }] };
  }
};
```

## Result Helpers

Import helper functions for common result patterns:

```typescript
import { textResult, errorResult, imageResult } from '@chucky.cloud/sdk';

// Text result
return textResult('Operation successful');
// → { content: [{ type: 'text', text: 'Operation successful' }] }

// Error result
return errorResult('File not found');
// → { content: [{ type: 'text', text: 'File not found' }], isError: true }

// Image result
return imageResult(base64Data, 'image/png');
// → { content: [{ type: 'image', data: '...', mimeType: 'image/png' }] }
```

## Types

```typescript
interface ToolDefinition {
  name: string;
  description: string;
  inputSchema: {
    type: 'object';
    properties: Record<string, PropertySchema>;
    required?: string[];
  };
  handler: (input: Record<string, any>) => Promise<ToolResult>;
}

interface ToolResult {
  content: Array<
    | { type: 'text'; text: string }
    | { type: 'image'; data: string; mimeType: string }
  >;
  isError?: boolean;
}

interface McpServer {
  name: string;
  version: string;
  tools: ToolDefinition[];
}
```
